#!/bin/bash

DEBUG=0
DIR_SCRIPT=$(dirname "${BASH_SOURCE[0]}")
PWNBOX_CONFIG="${DIR_SCRIPT}/pwnbox-config.json"

COLOR_CYAN_BOLD="\e[1;36m"
COLOR_GREEN_BOLD="\e[1;32m"
COLOR_YELLOW_BOLD="\e[1;33m"
COLOR_RED_BOLD="\e[1;31m"
COLOR_RST="\e[0m"

SIGN_PASS="\xE2\x9C\x94" # Unicode tick
SIGN_WARNING="\xE2\x9A\xA0" # Unicode warning sign
SIGN_FAIL="\xE2\x9C\x97" # Unicode cross
SIGN_INFO="*"
SIGN_QUESTION="?"

function print_info() {
    echo -e "${COLOR_CYAN_BOLD}${SIGN_INFO}${COLOR_RST} $1"
}

function print_debug() {
    if [ $DEBUG == 1 ]
    then
        if [ $# == 1 ]
        then
            echo -e "${COLOR_CYAN_BOLD}[DEBUG]${COLOR_RST} $1"
        elif [ $# == 2 ]
        then
            echo -e "${COLOR_CYAN_BOLD}[DEBUG]${COLOR_RST} '${1}'@'${BASH_SOURCE[0]}': ${2}"
        fi
    fi
}

function print_success() {
    echo -e "${COLOR_GREEN_BOLD}${SIGN_PASS}${COLOR_RST} $1"
}

function print_warning() {
    echo -e "${COLOR_YELLOW_BOLD}${SIGN_WARNING}${COLOR_RST} $1" >&2
}

function print_error() {
    if [ $# == 1 ]
    then
        echo -e "${COLOR_RED_BOLD}${SIGN_FAIL}${COLOR_RST} $1" >&2
    elif [ $# == 2 ]
    then
        echo -e "${COLOR_RED_BOLD}${SIGN_FAIL}${COLOR_RST} '${1}'@'${BASH_SOURCE[0]}' failed with error: ${2}" >&2
    fi
}

print_debug "PWNBOX_CONFIG=${PWNBOX_CONFIG}"
if [ ! -f "$PWNBOX_CONFIG" ]
then
    print_error "File '${PWNBOX_CONFIG}' does not exist."
    exit
fi

which jq >/dev/null
if [ $? != 0 ]
then
    print_error "Cound not find command 'jq'. Run 'apt install jq' first."
    exit
fi

# DESCRIPTION
#     Run a command, silently or not.
# ARGUMENTS
#     silent - Set to 1 to run silently, 0 otherwise
#     command - Command to run
# RETURN CODE
#     0  - Everything is fine
#     1  - Invalid number of arguments
#     2  - First argument is invalid
#     ?  - Return code of the command
function exec_command() {
    return_code=0
    if [ $# == 2 ]
    then
        if [ "$1" == "0" -o "$1" == "1" ]
        then
            print_debug "exec_command" "Running command: ${2}"
            command_output=$(eval $2 2>&1)
            command_return_code=$?
            print_debug "exec_command" "Command's return code: ${command_return_code}"
            if [ $command_return_code == 0 ]
            then
                if [ "$1" == "0" ]
                then
                    echo "$command_output"
                fi
            else
                print_error "exec_command" "The following command did not run properly: ${2}"
                echo "$command_output"
                return_code=$command_return_code
            fi
        else
            print_error "exec_command" "First argument is incorrect: ${1}"
            return_code=2
        fi
    else
        print_error "exec_command" "Invalid number of arguments: ${#}"
        return_code=1
    fi
    return $return_code
}

# ARGUMENTS
#     command - Command to execute
#     msg - Status message
function exec_command_and_print_status() {
    return_code=0
    if [ $# == 2 ]
    then
        echo -ne "${COLOR_CYAN_BOLD}${SIGN_INFO}${COLOR_RST} ${2}..."
        command_output=$(exec_command "0" "$1")
        return_code=$?
        if [ $return_code == 0 ]
        then
            echo -e "\r${COLOR_GREEN_BOLD}${SIGN_PASS}${COLOR_RST} ${2}    "
        else
            echo -e "\r${COLOR_RED_BOLD}${SIGN_FAIL}${COLOR_RST} ${2}    "
            echo "$command_output"
        fi
        if [ $DEBUG == 1 ]
        then
            echo "$command_output"
        fi
    else
        print_error "exec_command_and_print_status" "Invalid number of arguments: ${#}"
    fi
    return $return_code
}

# DESCRIPTION
#     Populates the global variables DIR_PUB and DIR_TOOLS that contain the path of the global 
#     public and tools directories.
# ARGUMENTS
#     None
# RETURN CODE
#     0  - Everything is fine
#     1  - Failed to find public directory path value
#     2  - Failed to find tools directory path value
function prepare_env() {
    return_code=0
    pwnbox_config=$(cat "$PWNBOX_CONFIG")
    which jq >/dev/null || return 127
    
    DIR_PUB=$(echo $pwnbox_config | jq -r .directories.dir_pub)
    DIR_TOOLS=$(echo $pwnbox_config | jq -r .directories.dir_tools)
    USER_NAME=$(logname)
    USER_HOME=$(eval echo ~$USER_NAME)
    
    print_debug "prepare_env" "DIR_PUB=${DIR_PUB}"
    print_debug "prepare_env" "DIR_TOOLS=${DIR_TOOLS}"
    print_debug "prepare_env" "USER_NAME=${USER_NAME}"
    print_debug "prepare_env" "USER_HOME=${USER_HOME}"
    
    if [ $DIR_PUB == "null" ]
    then
        return_code=1
    else
        if [ $DIR_TOOLS == "null" ]
        then
            return_code=2
        fi
    fi
    return $return_code
}

# DESCRIPTION
#     Returns the target path given a category name.
# ARGUMENTS
#     category - Category for which we need to retrieve the path
# RETURN CODE
#     0  - Everything is fine
#     1  - First argument is required: category
function get_category_path() {
    return_code=0
    if [ "$1" == "" ]
    then
        print_error "get_category_path" "Argument 1 (category) is required"
        return_code=1
    else
        echo -n "${DIR_TOOLS}/${1}"
    fi
    return $return_code
}

# DESCRIPTION
#     Check whether the current user is root.
# ARGUMENTS
#     None
# RETURN CODE
#     0  - Current user is root
#     1  - Current user is not root
function check_root_impl() {
    return_code=0
    if [ $(id -u) != 0 ]
    then
        print_error "Current user is not root."
        return_code=1
    fi
    return $return_code
}

function check_root() {
    exec_command_and_print_status "check_root_impl" "Current user permissions"
    return $?
}

# DESCRIPTION
#     Check if we have access to the Internet.
# ARGUMENTS
#     None
# RETURN CODE
#     0  - Everything is fine
#     1  - Failed to curl https://ifconfig.io/
function check_internet_access_impl() {
    return_code=0
    url="https://ifconfig.io"
    print_debug "check_internet_access_impl" "Checking URL ${url}"
    curl -s --connect-timeout 3 "$url" >/dev/null 2>&1
    if [ $? == 0 ]
    then
        print_debug "check_internet_access_impl" "Successfully curled ${url}"
    else
        print_error "check_internet_access_impl" "Failed to curl '${url}'"
	return_code=1
    fi
    return $return_code
}

function check_internet_access() {
    exec_command_and_print_status "check_internet_access_impl" "Internet connectivity"
    return $?
}

# DESCRIPTION
#     Wrapper
# ARGUMENTS
#     None
# RETURN CODE
#     0  - Everything is fine
#     ?  - Return the exit status of the last executed command that failed
function update_system() {
    export DEBIAN_FRONTEND=noninteractive
    exec_command_and_print_status "apt-get update" "Update APT package information" || return $?
    exec_command_and_print_status "apt-get dist-upgrade -o Dpkg::Options::=--force-confold -o Dpkg::Options::=--force-confdef -qq -y --allow-downgrades --allow-remove-essential --allow-change-held-packages" "Upgrade all APT packages" || return $?
    exec_command_and_print_status "apt-get autoclean -y" "Clear APT package cache" || return $?
    exec_command_and_print_status "apt-get autoremove -y" "Remove APT packages that are no long required" || return $?
    which snap >/dev/null
    if [ $? == 0 ]
    then
        exec_command_and_print_status "snap refresh" "Update snap packages"
    fi
    return 0
}

# DESCRIPTION
#     Update Nessus if installed.
# ARGUMENTS
#     None
# RETURN CODE
#     0  - Everything is fine
#     ?  - Return the exit status of the last executed command that failed  
function update_nessus () {
    dir_tools_nessus=$(get_category_path "nessus")
    print_debug "update_nessus" "Nessus diriectory: ${dir_tools_nessus}"
    if [ $? == 0 ]
    then
        if [ -d $dir_tools_nessus ]
        then
            exec_command_and_print_status "service nessusd stop" "Stop Nessus service" || return $?
            exec_command_and_print_status "$dir_tools_nessus/sbin/nessuscli update --all" "Update Nessus core and plugins" || return $?
        fi
    fi
    return 0
}

function install_apt_packages() {
    which jq >/dev/null || return 127
    pwnbox_config=$(cat "$PWNBOX_CONFIG")
    apt_packages=$(echo "$pwnbox_config" | jq -r '.packages.apt[]')
    apt_packages_arg=$(echo $apt_packages)
    export DEBIAN_FRONTEND=noninteractive
    exec_command_and_print_status "apt-get install -o Dpkg::Options::=--force-confold -o Dpkg::Options::=--force-confdef -qq -y --allow-downgrades --allow-remove-essential --allow-change-held-packages ${apt_packages_arg}" "Install additional APT packages" || return $?
    return 0
}

function install_ruby_packages() {
    which jq >/dev/null || return 127
    pwnbox_config=$(cat "$PWNBOX_CONFIG")
    ruby_packages=$(echo "$pwnbox_config" | jq -r '.packages.ruby[]')
    ruby_packages_arg=$(echo $ruby_packages)
    exec_command_and_print_status "gem install ${ruby_packages_arg}" "Install additional ruby gems" || return $?
    return 0
}

function update_ruby_packages() {
    which jq >/dev/null || return 127
    pwnbox_config=$(cat "$PWNBOX_CONFIG")
    ruby_packages=$(echo "$pwnbox_config" | jq -r '.packages.ruby[]')
    ruby_packages_arg=$(echo $ruby_packages)
    exec_command_and_print_status "gem update ${ruby_packages_arg}" "Update ruby gems" || return $?
    return 0
}

function install_python_packages() {
    which jq >/dev/null || return 127
    pwnbox_config=$(cat "$PWNBOX_CONFIG")
    python_packages=$(echo "$pwnbox_config" | jq -r '.packages.python[]')
    python_packages_arg=$(echo $python_packages)
    exec_command_and_print_status "pip3 install ${python_packages_arg}" "Install additional python packages" || return $?
    return 0
}

function update_python_packages() {
    which jq >/dev/null || return 127
    pwnbox_config=$(cat "$PWNBOX_CONFIG")
    python_packages=$(echo "$pwnbox_config" | jq -r '.packages.python[]')
    python_packages_arg=$(echo $python_packages)
    exec_command_and_print_status "pip3 install ${python_packages_arg} --upgrade" "Update python packages" || return $?
    return 0
}

function download_misc_binaries() {
    which jq >/dev/null || return 127
    pwnbox_config=$(cat "$PWNBOX_CONFIG")
    for bin in $(echo "$pwnbox_config" | jq -r '.binaries[] | @base64')
    do
        bin_data=$(echo $bin | base64 -d)
        name=$(echo $bin_data | jq -r '.name')
        print_debug "download_misc_binaries" "Binary name: ${name}"
        url=$(echo $bin_data | jq -r '.url')
        category=$(echo $bin_data | jq -r '.category')
        script=$(echo $bin_data | jq -r '.script')
        directory="$(get_category_path $category)/${name}-bin"
        print_debug "download_misc_binaries" "Download directory: ${directory}"
        if [ ! -d "$directory" ]
        then
            mkdir -p "$directory"
            pushd "$directory" >/dev/null
            exec_command_and_print_status "wget --quiet '${url}'" "Download binary '${name}'"
            if [ $? == 0 ]
            then
                if [ "$script" != "null" ]
                then
                    exec_command "1" "$script"
                fi
            fi
            popd >/dev/null
        fi
    done
}

function download_or_update_git_repositories() {
    which jq >/dev/null || return 127
    pwnbox_config=$(cat "$PWNBOX_CONFIG")
    for repo in $(echo "$pwnbox_config" | jq -r '.git_repositories[] | @base64')
    do
        repo_data=$(echo $repo | base64 -d)
        user=$(echo $repo_data | jq -r '.user')
        project=$(echo $repo_data | jq -r '.project')
        category=$(echo $repo_data | jq -r '.category')
        script=$(echo $repo_data | jq -r '.script')
        directory=$(get_category_path $category)
        if [ "$user" != "null" -a "$project" != "null" ]
        then
            url="https://github.com/${user}/${project}"
            if [ ! -d "$directory" ]
            then
                mkdir -p "$directory"
            fi
            if [ -d "$directory/${project}" ]
            then
                # The directory already exists, try to update it
                print_debug "download_or_update_git_repositories" "Target directory '${directory}/${project}' exists"
                pushd "$directory/${project}" >/dev/null
                
                if [ -d "$directory/${project}/.git" ]
                then
                    # It's a GIT repository
                    echo -ne "${COLOR_CYAN_BOLD}${SIGN_INFO}${COLOR_RST} GIT repository '${user}/${project}'"
                    if [ $(git fetch --dry-run 2>&1 | wc -l) -gt 0 ]
                    then
                        echo -e "\r${COLOR_YELLOW_BOLD}${SIGN_WARNING}${COLOR_RST} GIT repository '${user}/${project}' needs to be updated"
                        exec_command_and_print_status "git pull --no-rebase" "Update GIT repository '${user}/${project}'"
                        if [ "$script" != "null" ]
                        then
                            pushd "$directory/${project}" >/dev/null
                            exec_command_and_print_status "$script" "Run custom install script for repository '${user}/${project}'"
                            popd >/dev/null
                        fi
                    else
                        echo -e "\r${COLOR_GREEN_BOLD}${SIGN_PASS}${COLOR_RST} GIT repository '${user}/${project}'"
                    fi
                else
                    echo -e "${COLOR_RED_BOLD}${SIGN_FAIL}${COLOR_RST} The directory '${directory}/${project}' is not a GIT repository"
                fi

                popd >/dev/null
            else
                # The directory doesn't exist, clone the repository
                print_debug "download_or_update_git_repositories" "Target directory '${directory}/${project}' does not exist"
                pushd "$directory" >/dev/null
                
                exec_command_and_print_status "git clone '${url}' --depth 1" "Clone GIT repository '${user}/${project}'"
                if [ "$script" != "null" ]
                then
                    pushd "$directory/${project}" >/dev/null
                    exec_command_and_print_status "$script" "Run custom install script for repository '${user}/${project}'"
                    popd >/dev/null
                fi
                
                popd >/dev/null
            fi
        fi
    done
}

# DESCRIPTION
#     Validate the content of a release to see if it is properly formatted.
# ARGUMENTS
#     file path - the path of a release file
# RETURN CODE
#     0  - Everything is fine
#     1  - Invalid number of arguments
#     2  - The target file does not exist
#     3  - Did not find the field 'USER'
#     4  - Did not find the field 'PROJECT'
#     5  - Did not find the field 'VERSION'
function validate_release_file() {
    return_code=0
    if [ $# == 1 ]
    then
        if [ -f "$1" ]
        then
            file_content=$(cat "$1")
            echo "$file_content" | grep -q -E "^USER=.+\$" || return 3
            echo "$file_content" | grep -q -E "^PROJECT=.+\$" || return 4
            echo "$file_content" | grep -q -E "^VERSION=.+\$" || return 5
        else
            return_code=2
        fi
    else
        return_code=1
    fi
    return $return_code
}

function download_or_update_git_releases() {
    which jq >/dev/null || return 127
    pwnbox_config=$(cat "$PWNBOX_CONFIG")
    for release in $(echo "$pwnbox_config" | jq -r '.git_releases[] | @base64')
    do
        release_data=$(echo $release | base64 -d)
        release_data_user=$(echo $release_data | jq -r '.user')
        release_data_project=$(echo $release_data | jq -r '.project')
        release_data_archive_password=$(echo $release_data | jq -r '.archive_password')
        release_data_category=$(echo $release_data | jq -r '.category')
        print_debug "download_or_update_git_releases" "Release ${release_data_user}/${release_data_project}"
        
        release_url="https://api.github.com/repos/${release_data_user}/${release_data_project}/releases/latest"
        release_directory="$(get_category_path $release_data_category)/${release_data_project}-bin"
        
        release_git_content=$(curl -L --silent $release_url)
        if [ $? != 0 ]
        then
            echo -e "${COLOR_RED_BOLD}${SIGN_FAIL}${COLR_RST} Failed to get GIT release information for '${release_data_user}/${release_data_project}'"
            continue
        fi
        release_git_version=$(echo "$release_git_content" | jq -r '.tag_name')
        
        # Check if a password is required to decompress the archive(s)
        if [ "$release_data_archive_password" != "" ]
        then
            echo "$release_data_archive_password" | grep -q -E "^UNKNOWN\$"
            if [ $? == 0 ]
            then
                # The value of the password is 'UNKNOWN', which means we don't know it beforehand, so
                # we'll have to extract it from the decsription.
                release_git_body=$(echo "$release_git_content" | jq -r '.body')
                for word in $(echo "$release_git_body")
                do
                    word_nb_chars=$(echo "$word" | wc -c)
                    if [ $word_nb_chars -gt 20 ]
                    then
                        release_data_archive_password=$word
                        print_debug "download_or_update_git_releases" "Found password: ${release_data_archive_password}"
                        break
                    fi
                done
            fi
        fi
        
        to_download=0
        
        if [ -d "$release_directory" ]
        then
            # If the target directory already exists, check if it needs to be updated. If the the 
            # folder is not up to date, remove the contnet and set the 'download' flag to true.
            print_debug "download_or_update_git_releases" "Target directory '${release_directory} exists"
            validate_release_file "${release_directory}/.release"
            if [ $? == 0 ]
            then
                print_debug "download_or_update_git_releases" "Target directory '${release_directory} contains a valid release file"
                release_file_version=$(cat "${release_directory}/.release" | grep -E "^VERSION=" | cut -d'=' -f2)
                echo -ne "${COLOR_CYAN_BOLD}${SIGN_INFO}${COLOR_RST} GIT release '${release_data_user}/${release_data_project}'"
                #release_git_version=$(echo "$release_git_content" | jq -r '.tag_name')
                if [ "$release_git_version" != "" -a "$release_git_version" != "null" ]
                then
                    if [ "$release_git_version" == "$release_file_version" ]
                    then
                        echo -e "\r${COLOR_GREEN_BOLD}${SIGN_PASS}${COLOR_RST} GIT release '${release_data_user}/${release_data_project}' (version: ${release_file_version}) is up to date"
                    else
                        echo -e "\r${COLOR_YELLOW_BOLD}${SIGN_WARNING}${COLOR_RST} GIT release '${release_data_user}/${release_data_project}' (version: ${release_file_version}) needs to be updated"
                        to_download=1
                    fi
                else
                    echo -e "\r${COLOR_YELLOW_BOLD}${SIGN_WARNING}${COLR_RST} Local version for '${release_data_user}/${release_data_project}' is null or empty"
                fi
            else
                print_debug "download_or_update_git_releases" "Target directory '${release_directory} does not contain a valid release file or it is invalid"
                to_download=1
            fi
            
            if [ $to_download == 1 ]
            then
                pushd "$release_directory" >/dev/null
                print_debug "download_or_update_git_releases" "We will remove everything in $(pwd)"
                rm -rf *
                popd >/dev/null
            fi
        else
            # If the target directory does not exist, create it and set the 'download' flat to true.
            print_debug "download_or_update_git_releases" "Target directory '${release_directory} does not exist"
            echo -e "${COLOR_YELLOW_BOLD}${SIGN_WARNING}${COLOR_RST} GIT release '${release_data_user}/${release_data_project}' does not exist locally"
            mkdir -p "$release_directory"
            if [ $? == 0 ]
            then
                to_download=1
            fi
        fi
        
        if [ $to_download == 1 ]
        then
            print_debug "download_or_update_git_releases" "We should download something"
            # Download the latest release
            
            release_git_urls=$(echo $release_git_content | jq -r '.assets[] | select(.).browser_download_url')
            for release_git_url in $(echo -e $release_git_urls)
            do
                print_debug "download_or_update_git_releases" "Target URL: ${release_git_url}"
                pushd "$release_directory" >/dev/null
                
                arch_name=$(basename $release_git_url)
                if [ "$release_data_archive_password" == "" -o "$release_data_archive_password" == "null" ]
                then
                    exec_command_and_print_status "download_uncompress_archive '${release_git_url}'" "Download and decompress file '${arch_name}'"
                else
                    exec_command_and_print_status "download_uncompress_archive '${release_git_url}' '${release_data_archive_password}'" "Download and decompress file '${arch_name}' (password protected)"
                fi
                
                popd >/dev/null
            done
            
            # Create the .release file
            release_file_content=$(echo "$release_file_content" | sed "s/^VERSION=.*/VERSION=${release_git_version}/g")
            release_file_content=""
            release_file_content="${release_file_content}USER=${release_data_user}"$'\n'
            release_file_content="${release_file_content}PROJECT=${release_data_project}"$'\n'
            release_file_content="${release_file_content}VERSION=${release_git_version}"$'\n'
            pushd "$release_directory" >/dev/null
            echo -e "${release_file_content}" > ".release"
            popd >/dev/null
        fi
    done
}

# ARGUMENTS
#     url - URL of the target file to download
#     password - An optional password to decrypt the archive
# RETURN CODE
#     0  - Everything is fine
#     1  - Failed to download
#     2  - Failed to decompress
function download_uncompress_archive () {
    # Usage:
    #   uncompress_archive <URL>
    return_code=0
    arch_url="$1"
    arch_password=""
    
    if [ $# == 2 -a "$2" != "null" ]
    then
        arch_password="$2"
    fi
    
    filefullname="${1##*/}"
    filename="${filefullname%.*}"
    fileext="${filefullname##*.}"
    
    exec_command "0" "wget --quiet '${arch_url}'"
    if [ $? == 0 ]
    then
        if [ "$fileext" == "zip" ]
        then
            print_debug "download_uncompress_archive" "File '$filefullname' looks like a ZIP archive."
            exec_command "0" "unzip '$filefullname' -d '$filename'" || return 2
            exec_command "0" "rm -f '$filefullname'"
        elif [ "$fileext" == "gz" ]
        then
            print_debug "download_uncompress_archive" "File '$filefullname' looks like a GZIP archive."
            exec_command "0" "gzip -d '$filefullname'" || return 2
        elif [ "$fileext" == "7z" ]
        then
            print_debug "download_uncompress_archive" "File '$filefullname' looks like a 7z archive."
            if [ $arch_password != "" ]
            then
                exec_command "0" "7z x -aou -p'$arch_password' $filefullname" || return 2
            else
                exec_command "0" "7z x -aou '$filefullname'" || return 2
            fi
            exec_command "0" "rm -f '$filefullname'"
        fi
    else
        print_error "download_uncompress_archive" "Failed to download file '${arch_url}'"
        return_code=1
    fi
    
    return $return_code
}

# ARGUMENTS
#     file - path of an rc file (e.g.: .bashrc, .zshrc)
#     alias - name of the alias
#     command - command to affect to alias
# RETURN CODE
#     0  - Everything is fine
#     1  - Invalid number of arguments
#     2  - Target file does not exist
function add_or_update_alias_rc_file() {
    return_code=0
    if [ $# == 3 ]
    then
        in_file=$1
        in_alias=$2
        in_command=$3
        alias_line="alias ${in_alias}=\"${in_command}\""
        if [ -f $in_file ]
        then
            # Check if alias already exists
            grep -q -E "^alias ${in_alias}=" $in_file
            if [ $? == 0 ]
            then
                # The alias already exists, check if it is equal to the supplied value
                grep -q -x "$alias_line" $in_file
                if [ $? != 0 ]
                then
                    # The alias in the file is different, need to update
                    alias_line=$(echo $alias_line | sed "s/\"/\\\\\"/g")
                    new_rc_file_content=$(cat $in_file | sed "s/^alias ${in_alias}=.*/${alias_line//\//\\/}/g")
                    new_rc_file_content_encoded=$(echo "$new_rc_file_content" | base64 -w0)
                    sudo -u $USER_NAME bash -c "echo $new_rc_file_content_encoded | base64 -d > ${in_file}"
                fi
            else
                # The alias does not exist
                alias_line_encoded=$(echo $alias_line | base64 -w0)
                sudo -u $USER_NAME bash -c "echo $alias_line_encoded | base64 -d >> ${in_file}"
            fi
        else
            print_error "add_or_update_alias_rc_file" "Target file '${in_file}' does not exist"
            return_code=2
        fi
    else
        print_error "add_or_update_alias_rc_file" "Invalid number of arguments"
        return_code=1
    fi
    return $return_code
}

function configure_aliases_impl() {
    which jq >/dev/null || return 127
    pwnbox_config=$(cat "$PWNBOX_CONFIG")
    for alias in $(echo "$pwnbox_config" | jq -r '.aliases[] | @base64')
    do
        alias_data=$(echo $alias | base64 -d)
        alias_alias=$(echo $alias_data | jq -r '.alias')
        alias_command=$(echo $alias_data | jq -r '.command')
        alias_category=$(echo $alias_data | jq -r '.category')
        
        if [ "$alias_category" != "" -a "$alias_category" != "null" ]
        then
            alias_command="$(get_category_path ${alias_category})/${alias_command}"
        fi
        
        if [ -f "${USER_HOME}/.bashrc" ]
        then
            add_or_update_alias_rc_file "${USER_HOME}/.bashrc" "$alias_alias" "$alias_command"
        fi
        
        if [ -f "${USER_HOME}/.zshrc" ]
        then
            add_or_update_alias_rc_file "${USER_HOME}/.zshrc" "$alias_alias" "$alias_command"
        fi
    done
    return 0
}

function configure_aliases() {
    exec_command_and_print_status "configure_aliases_impl" "Configure or update aliases"
    return $?
}

#     0  - Everything is fine
#     1  - A target program was not resolved to its full path
#     2  - A target program was not found
#     3  - A symlink is invalid
function configure_symlinks_impl() {
    return_code=0
    which jq >/dev/null || return 127
    pwnbox_config=$(cat "$PWNBOX_CONFIG")
    for symlink in $(echo "$pwnbox_config" | jq -r '.symlinks[] | @base64')
    do
        symlink_data=$(echo $symlink | base64 -d)
        symlink_target=$(echo $symlink_data | jq -r '.target')
        symlink_link_name=$(echo $symlink_data | jq -r '.link_name')
        symlink_category=$(echo $symlink_data | jq -r '.category')
        
        if [ "$symlink_category" != "" -a "$symlink_category" != "null" ]
        then
            symlink_target="$(get_category_path $symlink_category)/${symlink_target}"
        else
            target_path=$(which $symlink_target)
            if [ $? == 0 ]
            then
                symlink_target="$target_path"
            else
                return_code=1
                print_error "configure_symlinks_impl" "Failed to resolve the path of '${symlink_target}'"
                continue
            fi
        fi
        
        if [ ! -f $symlink_target ]
        then
            return_code=2
            print_error "configure_symlinks_impl" "Target file '${symlink_target}' does not exist"
            continue
        fi
        
        # Do something only if no error occurred
        # Check if link already exists
        if [ -f $symlink_link_name ]
        then
            current_link_target=$(readlink $symlink_link_name)
            if [ $? == 0 ]
            then
                # This is a symlink
                if [ "$current_link_target" == "$symlink_target" ]
                then
                    print_debug "configure_symlinks_impl" "Symlink '${symlink_target}' is already set"
                else
                    print_debug "configure_symlinks_impl" "Symlink '${symlink_target}' needs to be updated"
                    rm -f "$symlink_target"
                    ln -s "$symlink_target" "$symlink_link_name"
                    return_code=$?
                fi
            else
                print_error "configure_symlinks_impl" "Failed to read symlink '${symlink_link_name}'"
                return_code=3
            fi
        else
            print_debug "configure_symlinks_impl" "Symlink '${symlink_link_name}' does not exist"
            ln -s "$symlink_target" "$symlink_link_name"
            return_code=$?
        fi
    done
    return $return_code
}

function configure_symlinks() {
    exec_command_and_print_status "configure_symlinks_impl" "Configure or update symlinks"
    return $?
}

function install_snap() {
    return_code=0
    # Make sure snap package was installed via APT first
    dpkg -l | grep -q -w snapd
    if [ $? == 0 ]
    then
        # Make sure snap command exist
        which snap >/dev/null
        if [ $? == 0 ]
        then
            exec_command_and_print_status "systemctl enable --now snapd apparmor" "Enable auto start for services 'snapd' and 'apparmor'" || return $?
            exec_command_and_print_status "snap install code --classic" "Install Visual Studio Code" || return $?
        else
            return_code=2
            print_error "install_snap" "Could not find command 'snap'."
        fi
    else
        return_code=1
        print_error "install_snap" "APT package 'snapd' does not seem to be installed."
    fi
    return $return_code
}

function configure_terminator_impl() {
    return_code=0
    terminator_dir="$USER_HOME/.config/terminator"
    terminator_config="$terminator_dir/config"
    sudo -u $USER_NAME bash -c "mkdir -p $terminator_dir"
    if [ -d "$terminator_dir" ]
    then
        sudo -u $USER_NAME bash -c "echo \"W2dsb2JhbF9jb25maWddCiAgc21hcnRfY29weSA9IEZhbHNlCiAgc3VwcHJlc3NfbXVsdGlwbGVfdGVybV9kaWFsb2cgPSBUcnVlCiAgdGl0bGVfZm9udCA9IFNhbnMgMTAKICB0aXRsZV9pbmFjdGl2ZV9iZ19jb2xvciA9ICIjODg4YTg1IgogIHRpdGxlX3RyYW5zbWl0X2JnX2NvbG9yID0gIiM2YjAwMDAiCiAgdGl0bGVfdHJhbnNtaXRfZmdfY29sb3IgPSAiI2VlZWVlYyIKICB0aXRsZV91c2Vfc3lzdGVtX2ZvbnQgPSBGYWxzZQpba2V5YmluZGluZ3NdCltsYXlvdXRzXQogIFtbZGVmYXVsdF1dCiAgICBbW1tjaGlsZDBdXV0KICAgICAgZnVsbHNjcmVlbiA9IEZhbHNlCiAgICAgIGxhc3RfYWN0aXZlX3Rlcm0gPSA3YWZhODdlMC01ODI4LTQwOGItYWY0MC1kYTQ5MjNlODE5MDYKICAgICAgbGFzdF9hY3RpdmVfd2luZG93ID0gVHJ1ZQogICAgICBtYXhpbWlzZWQgPSBUcnVlCiAgICAgIG9yZGVyID0gMAogICAgICBwYXJlbnQgPSAiIgogICAgICBwb3NpdGlvbiA9IDA6MjcKICAgICAgc2l6ZSA9IDE2MDAsIDgwMAogICAgICB0aXRsZSA9IFRlcm1pbmF0b3IKICAgICAgdHlwZSA9IFdpbmRvdwogICAgW1tbY2hpbGQxXV1dCiAgICAgIG9yZGVyID0gMAogICAgICBwYXJlbnQgPSBjaGlsZDAKICAgICAgcG9zaXRpb24gPSA0MDAKICAgICAgcmF0aW8gPSAwLjUKICAgICAgdHlwZSA9IFZQYW5lZAogICAgW1tbY2hpbGQyXV1dCiAgICAgIG9yZGVyID0gMAogICAgICBwYXJlbnQgPSBjaGlsZDEKICAgICAgcG9zaXRpb24gPSA4MDAKICAgICAgcmF0aW8gPSAwLjUKICAgICAgdHlwZSA9IEhQYW5lZAogICAgW1tbY2hpbGQ1XV1dCiAgICAgIG9yZGVyID0gMQogICAgICBwYXJlbnQgPSBjaGlsZDEKICAgICAgcG9zaXRpb24gPSA4MDEKICAgICAgcmF0aW8gPSAwLjUwMDYyNQogICAgICB0eXBlID0gSFBhbmVkCiAgICBbW1t0ZXJtaW5hbDNdXV0KICAgICAgb3JkZXIgPSAwCiAgICAgIHBhcmVudCA9IGNoaWxkMgogICAgICBwcm9maWxlID0gZGVmYXVsdAogICAgICB0eXBlID0gVGVybWluYWwKICAgICAgdXVpZCA9IDdhZmE4N2UwLTU4MjgtNDA4Yi1hZjQwLWRhNDkyM2U4MTkwNgogICAgW1tbdGVybWluYWw0XV1dCiAgICAgIG9yZGVyID0gMQogICAgICBwYXJlbnQgPSBjaGlsZDIKICAgICAgcHJvZmlsZSA9IGRlZmF1bHQKICAgICAgdHlwZSA9IFRlcm1pbmFsCiAgICAgIHV1aWQgPSAyOGE4MzIxNS0yNTk4LTRiZTEtOGRkMy05NjdmNjkzNTQxNGUKICAgIFtbW3Rlcm1pbmFsNl1dXQogICAgICBvcmRlciA9IDAKICAgICAgcGFyZW50ID0gY2hpbGQ1CiAgICAgIHByb2ZpbGUgPSBkZWZhdWx0CiAgICAgIHR5cGUgPSBUZXJtaW5hbAogICAgICB1dWlkID0gNGI2ZGExMmUtM2VkOS00OTBiLWI0MGQtYjYxN2Y4NWQyMDY4CiAgICBbW1t0ZXJtaW5hbDddXV0KICAgICAgb3JkZXIgPSAxCiAgICAgIHBhcmVudCA9IGNoaWxkNQogICAgICBwcm9maWxlID0gZGVmYXVsdAogICAgICB0eXBlID0gVGVybWluYWwKICAgICAgdXVpZCA9IGRhMTAwMTc5LThhYmItNDljZS04NzZhLTIxNjBjM2MzOTc0ZApbcGx1Z2luc10KW3Byb2ZpbGVzXQogIFtbZGVmYXVsdF1dCiAgICBjdXJzb3JfY29sb3IgPSAiI2VlZWVlYyIKICAgIGN1cnNvcl9jb2xvcl9mZyA9IEZhbHNlCiAgICBmb250ID0gTW9ub3NwYWNlIDkKICAgIGZvcmVncm91bmRfY29sb3IgPSAiI2ZmZmZmZiIKICAgIGljb25fYmVsbCA9IEZhbHNlCiAgICBzY3JvbGxiYWNrX2luZmluaXRlID0gVHJ1ZQogICAgdXNlX3N5c3RlbV9mb250ID0gRmFsc2UKCg==\" | base64 -d > $terminator_config"
    else
        return_code=1
        print_error "configure_terminator" "Directory '${terminator_dir}' does not exist"
    fi
    return $return_code
}

function configure_terminator() {
    exec_command_and_print_status "configure_terminator_impl" "Create Terminator config file"
    return $?
}

function configure_smb_share_impl() {
    return_code=0
    dir_pub_loot="${DIR_PUB}/loot"
    dir_pub_tools="${DIR_PUB}/tools"
    dir_pub_temp="${DIR_PUB}/temp"
    smb_config="/etc/samba/smb.conf"
    smb_config_bak="/etc/samba/smb.conf.bak"
    html_default='<html><body bgcolor="#000000"><h1><center><font color="#cc0000">WhAt ArE yOu DoInG tHeRe???</font></center></h1></body></html>'
    which smbd >/dev/null
    if [ $? == 0 ]
    then
        mv $smb_config $smb_config_bak
        adduser --system shareuser
        mkdir -p $dir_pub_loot $dir_pub_tools $dir_pub_temp
        chmod ugo=rwx $DIR_PUB
        chmod u=rwx,go=wx $dir_pub_loot # We can write but not list its content
        chmod u=rwx,go=rx $dir_pub_tools # We can read/execute but not write 
        chmod 777 $dir_pub_temp # All access on the temp folder 
        echo "W2dsb2JhbF0KICAgIG1hcCB0byBndWVzdCA9IEJhZCBVc2VyCiAgICBsb2cgZmlsZSA9IC92YXIvbG9nL3NhbWJhLyVtCiAgICBsb2cgbGV2ZWwgPSAxCiAgICBzZWN1cml0eSA9IHVzZXIKICAgIHBhc3NkYiBiYWNrZW5kID0gdGRic2FtICAKCltwdWIkXQogICAgIyBTaGFyZSBkZXNjcmlwdGlvbiAKICAgIGNvbW1lbnQgPSBBbGwgUHJpbnRlcnMgIAogICAgIyBMb2NhbCBmb2xkZXIgdG8gc2hhcmUgCiAgICBwYXRoID0gL3B1YgogICAgIyBNYWtlIGl0ICdpbnZpc2libGUnCiAgICBicm93c2VhYmxlID0gbm8KICAgICMgRW5hYmxlIGFub255bW91cyBhY2Nlc3MgCiAgICBwdWJsaWMgPSB5ZXMKICAgIGd1ZXN0IG9rID0geWVzCiAgICAjIE5vdCBhIHByaW50ZXIgc2hhcmUgCiAgICBwcmludGFibGUgPSBubwogICAgIyBUaGUgc2hhcmUgaXMgbm90IHJlYWQtb25seSAobG9vdCBmb2xkZXIpCiAgICByZWFkIG9ubHkgPSBubwogICAgIyBFbmFibGUgd3JpdGUgYWNjZXNzIAogICAgd3JpdGFibGUgPSB5ZXMKICAgICMgRW5hYmxlIGhpZGRlbiBmaWxlcyAoc3RhcnRpbmcgd2l0aCBhIGRvdCkKICAgIGhpZGUgZG90IGZpbGVzID0geWVzCiAgICAjIEhpZGUgZm9sZGVycyAvIGV4dGVuc2lvbnMgCiAgICAjaGlkZSBmaWxlcyA9IC8qLwogICAgZm9yY2UgdXNlciA9IHNoYXJldXNlcgo=" | base64 -d > $smb_config
        echo $html_default > "$DIR_PUB/index.html"
        echo $html_default > "$dir_pub_tools/index.html"
        echo $html_default > "$dir_pub_loot/index.html"
        service smbd stop
        service smbd start
        service smbd stop
    else
        return_code=1
        print_error "configure_smb_share_impl" "Could not find command 'smbd'"
    fi
    return $return_code
}

function configure_smb_share() {
    exec_command_and_print_status "configure_smb_share_impl" "Configure Samba and public directories"
    return $?
}

function configure_metasploit_impl() {
    return_code=0
    systemctl start postgresql
    if [ $? == 0 ]
    then
        systemctl enable --now postgresql
        if [ $? == 0 ]
        then
            msfdb init
            if [ $? == 0 ]
            then
                print_success "MSF DB initialized"
            else
                return_code=3
                print_error "configure_metasploit_impl" "Failed to initialize MSF DB"
            fi
        else
            return_code=2
            print_error "configure_metasploit_impl" "Failed to set PosgreSQL service auto start"
        fi
    else
        return_code=1
        print_error "configure_metasploit_impl" "Failed to start PosgreSQL service"
    fi
    update-rc.d postgresql enable
    msfdb init
    return $return_code
}

function configure_metasploit() {
    exec_command_and_print_status "configure_metasploit_impl" "Initialize MSF database"
    return $?
}

function configure_xfce_impl() {
    return_code=0
    which xfconf-query >/dev/null
    if [ $? == 0 ]
    then
        # Power management > Display > Blank after: Never 
        xfconf-query -c "xfce4-power-manager" -p "/xfce4-power-manager/blank-on-ac" -s 0
        # Power management > Display > Put to sleep after: Never
        xfconf-query -c "xfce4-power-manager" -p "/xfce4-power-manager/dpms-on-ac-sleep" -s 0
        # Power management > Display > Switch off after: Never
        xfconf-query -c "xfce4-power-manager" -p "/xfce4-power-manager/dpms-on-ac-off" -s 0
        # Desktop > Background > Wallpaper
        xfconf-query -c "xfce4-desktop" -p "/backdrop/screen0/monitorVirtual1/workspace0/last-image" -s "/usr/share/backgrounds/kali/kali-small-logo.png"
        # Panel > Rwo size: 36
        xfconf-query -c "xfce4-panel" -p "/panels/panel-1/size" -s 36
        # Panel > Don't show Window titles
        xfconf-query -c "xfce4-panel" -p "/plugins/plugin-12/show-labels" -s false
    else
        return_code=1
        print_error "configure_xfce_impl" "Could not find command 'xfconf-query'"
    fi
    return $return_code
}

function configure_xfce() {
    exec_command_and_print_status "configure_xfce_impl" "Configure XFCE settings"
    return $?
}

function update_file_database() {
    exec_command_and_print_status "updatedb" "Update file database with 'updatedb'"
    return $?
}

function shutdown_network_manager() {
    return_code=0
    for s in $(echo -e "network-manager\nNetworkManager")
    do
        systemctl status $s >/dev/null 2>&1
        if [ $? == 0 ]
        then
            exec_command_and_print_status "systemctl stop $s" "Kill service '$s'"
            return_code=$?
        fi
    done
    return $return_code
}

function renew_interface_ip_address() {
    return_code=0
    if [ $# == 0 ]
    then
        print_error "renew_interface_ip_address" "Invalid number of arguments, an interface name is required."
        return_code=1
    else
        in_ifname=$1
        in_mac_addr=$2
        ifconfig $in_ifname >/dev/null 2>&1
        if [ $? == 0 ]
        then
            # Kill any instances of dhclient
            for p in $(pidof dhclient | sed s/' '/'\n'/g)
            do
                exec_command_and_print_status "kill $p" "Kill process dhclient with PID $p"
            done
            # Shut down interface
            exec_command_and_print_status "ifconfig $in_ifname down" "Shut down interface $in_ifname"
            if [ $? == 0 ]
            then
                # Change MAC address
                if [ $# -gt 1 ]
                then
                    exec_command_and_print_status "macchanger -m $in_mac_addr $in_ifname" "Set MAC address $in_mac_addr on interface $in_ifname"
                else
                    exec_command_and_print_status "macchanger -r $in_ifname" "Set random MAC address on interface $in_ifname"
                    if [ $? == 0 ]
                    then
                        info_mac=$(ifconfig $in_ifname | grep ether | awk '{ print $2 }')
                        print_info "Got MAC address: $info_mac"
                    fi
                fi
                if [ $? == 0 ]
                then
                    # Start interface
                    exec_command_and_print_status "ifconfig $in_ifname up" "Enable interface $in_ifname"
                    # Send DHCP request
                    exec_command_and_print_status "dhclient $in_ifname" "Send DHCP request on interface $in_ifname"
                    if [ $? == 0 ]
                    then
                        info_ip_addr=$(ifconfig $in_ifname | grep inet | awk '{ print $2 }')
                        info_netmask=$(ifconfig $in_ifname | grep inet | awk '{ print $4 }')
                        info_broadcast=$(ifconfig $in_ifname | grep inet | awk '{ print $6 }')
                        info_gw=$(ip r | grep default | awk '{ print $3 }')
                        print_info "Got IP address: $info_ip_addr ($info_netmask)"
                        print_info "Default gateway: $info_gw"
                    fi
                fi
            else
                return_code=$?
            fi
        else
            print_error "renew_interface_ip_address" "Interface '$in_ifname' does not exist."
            return_code=2
        fi
    fi
    return $return_code
}

function prompt_confirm {
    return_code=0
    echo -ne "${COLOR_YELLOW_BOLD}${SIGN_QUESTION}${COLOR_RST} "
    read -r -p "Please confirm to proceed [y/N] " response
    if [[ "${response}" =~ ^([yY][eE][sS]|[yY])$ ]]
    then
        return_code=0
    else
        return_code=1
    fi
    return $return_code
}